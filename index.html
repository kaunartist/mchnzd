<html>
  <head>
    <meta charset="utf-8">
    <title>MCHNZD</title>
    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <script src="pixi.min.js"></script>
  <script src="sound.js"></script>
  <body>
  <script type="text/javascript">
    class TankHud extends PIXI.Container {
      constructor() {
        super();
        this.leftGear = new PIXI.Text("1", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.leftGear.position.set(10, 0);
        this.gas = new PIXI.Text("GAS", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.gas.position.set(30, 0);
        this.rightGear = new PIXI.Text("1", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.rightGear.position.set(90, 0);
        this.bodyRotation = new PIXI.Text("0", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.bodyRotation.position.set(120, 0);
        this.turretRotation = new PIXI.Text("0", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.turretRotation.position.set(180, 0);
        this.ammo = new PIXI.Text("10", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.ammo.position.set(260, 0);
        this.cooldown = new PIXI.Text("0", {fontFamily: "Futura", fontSize: 12, fill: "red"});
        this.cooldown.position.set(310, 0);
        this.addChild(this.leftGear);
        this.addChild(this.rightGear);
        this.addChild(this.gas);
        this.addChild(this.bodyRotation);
        this.addChild(this.turretRotation);
        this.addChild(this.ammo);
        this.addChild(this.cooldown);
      }
    }

    class Projectile extends PIXI.Graphics {
      constructor(player, x, y, vx, vy, angle) {
        super();
        this.player = player;
        this.beginFill(0xFFFFFF).lineStyle(0.5, 0xFF0000).drawRect(0, 0, 6, 2).endFill();
        this.vx = vx;
        this.vy = vy;
        this.position.set(x, y);
        this.rotation = angle;
        this.ttl = 40;
      }
    }

    class Tank extends PIXI.Container {
      constructor(x, y) {
        super();
        this.tankbody = new PIXI.Graphics();
        this.tankbody.beginFill(0x000000).lineStyle(0.5, 0xffffff).drawRect(0, 0, 40, 40).endFill();

        this.turret = new PIXI.Container();
        var turretbase = new PIXI.Graphics();
        turretbase.beginFill(0x000000).lineStyle(0.5, 0xffffff).drawCircle(0, 0, 10).endFill();
        var turretbarrel = new PIXI.Graphics();
        turretbarrel.beginFill(0x000000).lineStyle(0.5, 0xffffff).drawRect(0, 0, 26, 4).endFill();
        turretbarrel.pivot.set(0, 2);

        this.hud = new TankHud();
        this.heading = new PIXI.Graphics();
        this.heading.lineStyle(2, 0x00FF00, 1);
        this.heading.moveTo(this.position.x + 30, this.position.y + 2);
        this.heading.lineTo(this.position.x + 50, this.position.y + 2);


        this.turret.addChild(turretbase);
        this.turret.addChild(turretbarrel);
        this.turret.position.set(20, 20);
        this.turretSpeed = 1; // how fast it rotates
        this.tankTurnSpeed = 0.1; // how fast the tank turns

        this.pivot.set(20, 20);

        this.power = 0;
        this.vx = 0;
        this.vy = 0;
        this.turretvelocity = 0;

        this.leftGear = 1;
        this.rightGear = 1;

        this.cooldown = 0;
        this.ammo = 10;

        this.clock = 30;

        this.addChild(this.tankbody);
        this.addChild(this.turret);
        this.position.set(x, y);
      }

      hasAmmo() {
        return this.ammo > 0 ? true : false;
      }

      fireProjectile() {
        // create a projectile with a heading/velocity
        this.ammo -= 1;
        this.cooldown = 150;

        var angle = this.rotation - Math.PI; 
        var turretAngle = this.turret.rotation;
        var deltaAngle = turretAngle + angle;
        var hx = Math.cos(deltaAngle); // velocity
        var hy = Math.sin(deltaAngle);
        var muzzlex = this.position.x - (hx * 33);
        var muzzley = this.position.y + 1 - (hy * 33);

        var round = new Projectile(this, muzzlex, muzzley, -hx * 10, -hy * 10, deltaAngle);
        return round;
      }

      rotateTurret(direction) {
        var rotateDelta = deg2rad(this.turretSpeed);
        this.turretvelocity = direction > 0 ? rotateDelta : -rotateDelta;
      }

      stopTurret() {
        this.turretvelocity = 0;
      }

      rotateTank(delta) {
        var rotateDelta = deg2rad(this.tankTurnSpeed * delta);
        this.rotation += rotateDelta;
      }

      engineOn() {
        this.power = 1;
        //this.vy = -2;
      }

      engineOff() {
        this.power = 0;
        //this.vy = 0;
      }

      gearUpLeft() {
        this.leftGear += 1;
        if (this.leftGear > 5) {
          this.leftGear = 5;
        }
      }

      gearDownLeft() {
        this.leftGear -= 1;
        if (this.leftGear < 0) {
          this.leftGear = 0;
        }
      }

      gearUpRight() {
        this.rightGear += 1;
        if (this.rightGear > 5) {
          this.rightGear = 5;
        }
      }

      gearDownRight() {
        this.rightGear -= 1;
        if (this.rightGear < 0) {
          this.rightGear = 0;
        }
      }
    }

    class FSM {
      constructor(startingState) {
        this.states = ['plan','move','action'];
        if (this.states.indexOf(startingState) != -1) {
          this.state = startingState;
        } else {
          this.state = 'plan';
        }
      }

      changeState(state) {
        if (this.states.indexOf(state) != -1) {
          this.state = state;
        }
      }

      getState() {
        return this.state;
      }
    }

    class TankBot extends Tank {
      constructor(x, y) {
        super(x, y);
        this.target = new PIXI.Point(x,y);
        this.state = new FSM('move');
      }

      plan() {
      }

      move() {
        if (this.isAtDestination()) {
          // what's next
          //console.log("At destination");
          this.engineOff();
          this.hud.gas.style.fill = 0xff0000;
          this.state.changeState('action');
        } else {
          var angle = this.isFacingTarget();
          if (angle == 0) {
            //console.log("facing destination, moving forward");
            //console.log(this.position.x + ", " + this.position.y);
            // we're pointing the right way, start moving
            this.moveForward();
          } else {
            // turn to face the target
            this.turnTo(this.getTarget(), angle);
          }
        }
      }

      action() {
      }

      setTarget(x, y) {
        //this.target.push(new PIXI.Point(x, y));
        this.target = new PIXI.Point(x, y);
      }

      getTarget() {
        return this.target;//.slice(0, 1);
      }

      isAtDestination() {
        var target = this.getTarget();
        //console.log(parseInt(this.position.x) + "," + parseInt(this.position.y) + " vs " + parseInt(target.x) + "," + parseInt(target.y));
        return parseInt(this.position.x) == parseInt(target.x) && parseInt(this.position.y) == parseInt(target.y);
      }

      moveForward() {
        if (this.power != 1) {
          this.engineOn();
          this.hud.gas.style.fill = 0x00ff00;
        }
        if (this.leftGear < this.rightGear) {
          // we are turning left
          this.gearUpLeft();
        } else if (this.leftGear > this.rightGear) {
          // we are turning right
          this.gearUpRight();
        } else if (this.leftGear < 1) {
          // we're in reverse
          this.gearUpLeft();
          this.gearUpRight();
        } else {
          // we're going forward
          if (this.leftGear < 5) {
            this.gearUpLeft();
            this.gearUpRight();
          }
        }
      }

      isFacingTarget() {
        var target = this.getTarget();
        var targetx = target.x - this.position.x;
        var targety = target.y - this.position.y;
        var magnitude = Math.sqrt((targetx * targetx) + (targety * targety));
        // Unit vector between position and target
        var target_ux = targetx / magnitude;
        var target_uy = targety / magnitude;

        // Unit vector of current heading
        var heading = this.rotation;
        var hx = Math.cos(heading);
        var hy = Math.sin(heading);
        var heading_magnitude = Math.sqrt((hx * hx) + (hy * hy));
        var heading_ux = hx / heading_magnitude;
        var heading_uy = hy / heading_magnitude;


        var dotproduct = (target_ux * heading_ux) + (target_uy * heading_uy);
        var angle = Math.acos(dotproduct);
        var degrees = rad2deg(angle);
        //console.log(parseInt(this.position.x) + "," + parseInt(this.position.y) + " vs " + parseInt(target.x) + "," + parseInt(target.y));
        //console.log(degrees);

        if (parseInt(degrees) < 0) {
          return -1;
        } else if (parseInt(degrees) > 0) {
          return 1;
        } else {
          return 0;
        }
      }

      turnTo(point, direction) {
        if (this.power != 1) {
          this.engineOn();
          this.hud.gas.style.fill = 0x00ff00;
        }

        if (direction < 0) {
          if (this.leftGear < this.rightGear) {
            // we're good
          } else if (this.leftGear == this.rightGear) {
            this.gearDownLeft();
          } else if (this.leftGear > this.rightGear) {
            this.gearUpRight();
            this.gearDownLeft();
          }
        } else if (direction > 0) {
          if (this.leftGear < this.rightGear) {
            this.gearUpLeft();
            //this.gearDownRight();
            //console.log("Gearing up left to turn");
            //console.log(this.leftGear + " / " + this.rightGear);
          } else if (this.leftGear == this.rightGear) {
            this.gearDownRight();
            //console.log("Gearing down right to turn");
            //console.log(this.leftGear + " / " + this.rightGear);
          } else if (this.leftGear > this.rightGear) {
            // we're good
          }
        }
      }
    }

    // END CLASS DEFINITIONS

    // GLOBALS
    var renderer, stage, player1, bots, heading, projectiles;
    var state = play;

    // GAME CODE
    setup();

    function setup() {
      renderer = PIXI.autoDetectRenderer(512, 512, {antialias: false});
      document.body.appendChild(renderer.view);
      stage = new PIXI.Container();
      projectiles = [];
      bots = [];

      //this code from a tutorial, don't quite trust it yet
      //Capture the keyboard arrow keys
      var rotateturretleft = keyboard(65),
          rotateturretright = keyboard(68),
          shoot = keyboard(32),
          utility = keyboard(70),
          leftgearup = keyboard(85),
          leftgeardown = keyboard(74),
          gas = keyboard(73),
          rightgearup = keyboard(79),
          rightgeardown = keyboard(76);

      //Shoot gun
      shoot.press = function() {
        if (player1.hasAmmo() && player1.cooldown == 0) {
          shootSound();
          var round = player1.fireProjectile();
          player1.hud.ammo.text = player1.ammo;
          player1.hud.cooldown.text = player1.cooldown;
          projectiles.push(round);
          stage.addChild(round);
        }
      };
      shoot.release = function() {
      };

      //Turret rotation
      rotateturretleft.press = function() {
        if (!rotateturretright.isDown) {
          player1.rotateTurret(-1);
        }
      };
      rotateturretleft.release = function() {
        player1.stopTurret();
      };

      //Turret rotation
      rotateturretright.press = function() {
        if (!rotateturretleft.isDown) {
          player1.rotateTurret(1);
        }
      };
      rotateturretright.release = function() {
        player1.stopTurret();
      };

      //Left track gear
      leftgearup.press = function() {
        if (!leftgeardown.isDown) {
          player1.gearUpLeft();
          player1.hud.leftGear.text = player1.leftGear;
        }
      };
      leftgearup.release = function() {

      };

      //Left track gear
      leftgeardown.press = function() {
        if (!leftgearup.isDown) {
          player1.gearDownLeft();
          player1.hud.leftGear.text = player1.leftGear;
        }
      };
      leftgeardown.release = function() {

      };

      //Gas
      gas.press = function() {
        player1.engineOn();
        player1.hud.gas.style.fill = 0x00ff00;
      };
      gas.release = function() {
        player1.engineOff();
        player1.hud.gas.style.fill = 0xff0000;
      };

      //Right
      rightgearup.press = function() {
        if (!rightgeardown.isDown) {
          player1.gearUpRight();
          player1.hud.rightGear.text = player1.rightGear;
        }
      };
      rightgearup.release = function() {
        //stopTurningRight();
      };

      //Down
      rightgeardown.press = function() {
        if (!rightgearup.isDown) {
          player1.gearDownRight();
          player1.hud.rightGear.text = player1.rightGear;
        }
      };
      rightgeardown.release = function() {
      };

      player1 = new Tank(70, 200);
      player1.hud.position.set(20, 480);
      stage.addChild(player1.hud);

      for (var b = 0; b < 4; b++) {
        var randx = randomInt(0, stage.width);
        var randy = randomInt(0, stage.height);
        var bot = new TankBot(randx, randy);
        stage.addChild(bot.hud);
        bot.hud.position.set(20, 20 + 20 * b);

        randx = randomInt(0, stage.width);
        randy = randomInt(0, stage.height);
        bot.setTarget(randx, randy);

        var circle = new PIXI.Graphics();
        circle.beginFill(0x9966FF);
        circle.drawCircle(0, 0, 2);
        circle.endFill();
        circle.x = randx;
        circle.y = randy;
        stage.addChild(circle);
        stage.addChild(bot);
        bots.push(bot);
      }

      stage.addChild(player1);
      gameLoop();
    }

    function gameLoop() {
      requestAnimationFrame(gameLoop);
      state();
      renderer.render(stage);
    }

    function play() {
      updateProjectiles();

      updatePlayers();

      updateBots();


      // actually move it based on those calculations
      if (player1.power == 1) {
        player1.clock++;
        if (player1.clock >= 30) {
          moveSound();
          player1.clock = 0;
        }
        player1.x += player1.vx;
        player1.y += player1.vy;
      }

      for (var b = 0; b < bots.length; b++) {
        var bot = bots[b];
        if (bot.power == 1) {
          // play movement sounds
          bot.clock++;
          if (bot.clock >= 30) {
            //moveSound();
            bot.clock = 0;
          }

          bot.x += bot.vx;
          bot.y += bot.vy;
        }
      }
    }

    function updateProjectiles() {
      for (var i=0; i < projectiles.length; i++) {
        var round = projectiles[i];
        round.x += round.vx;
        round.y += round.vy;
        round.ttl -= 1;
        if (round.ttl < 0) {
          var pos = projectiles.indexOf(round);
          projectiles.splice(pos, 1);
          stage.removeChild(round);
        }
      }
    }

    function updatePlayers() {
      // eventually do a foreach, for now just one player
      turnTurret(player1);
      turnTank(player1);
      if (player1.cooldown > 0) {
        player1.cooldown -= 1;
        player1.hud.cooldown.text = player1.cooldown;
      }
    }

    function updateBots() {
      for (var b = 0; b < bots.length; b++) {
        var bot = bots[b];
        var state = bot.state.getState();
        if (state == 'plan') {
          bot.plan();
        } else if (state == 'move') {
          bot.move();
        } else if (state == 'action') {
          bot.action();
        }
        turnTank(bot);
      }
    }

    function turnTurret(player) {
      player.turret.rotation += player.turretvelocity;
      player.hud.turretRotation.text = parseInt(rad2deg(player.turret.rotation));
      if (player.turret.rotation > Math.PI * 2) {
        player.turret.rotation = 0;
      } else if (player.turret.rotation < -Math.PI * 2) {
        player.turret.rotation = 0;
      }

      updateHeading(1, player);
    }

    function turnTank(player) {
      // compare left and right, turn in that direction
      // left -> [0,1,2,3,4,5]
      // right -> [0,1,2,3,4,5]
      if (player.power == 1) {
        var left = player.leftGear < 1 ? -3 : player.leftGear;
        var right = player.rightGear < 1 ? -3 : player.rightGear;
        var delta = left - right;
        if (delta != 0) {
          player.rotateTank(delta);
          var angle = player.rotation;
          var hx = Math.cos(angle);
          var hy = Math.sin(angle);

          if ((left < 1 && right < 3) || (right < 1 && left < 3)) {
            // back up if one tread is going in reverse stronger than the other is going forward
            player.vx = -hx / 2;
            player.vy = -hy / 2;
          } else {
            // this needs work, it should not be an even acceleration at all gears
            // turns at 1/2, 2/3, etc. should be slower than a turn at 4/5
            player.vx = hx * 0.8;
            player.vy = hy * 0.8;
            //console.log(delta);
          }

          updateHeading(1, player);

          if (player.rotation > Math.PI * 2) {
            player.rotation = 0;
          } else if (player.rotation < -Math.PI * 2) {
            player.rotation = 0;
          }
          player.hud.bodyRotation.text = parseInt(rad2deg(player.rotation));
        } else {
          var angle = player.rotation - Math.PI; 
          var hx = Math.cos(angle);
          var hy = Math.sin(angle);

          if (left < 1 && right < 1) { // we're in reverse

            player.vx = hx / 2;
            player.vy = hy / 2;

            updateHeading(1, player);

          } else { // we're going straight forward
            // this formula needs adjusting, going forward is slower than turning at all gears except 5
            // if left = 5, vx = -hx        and that's about good
            // if left = 4, vx = -hx / 2    this should be more like 1.2
            // if left = 3, vx = -hx / 3    and 1.4
            // if left = 2, vx = -hx / 4    and 1.6
            // if left = 1, vx = -hx / 5    and 1.8 or 2

            // what about (5 - left)/5?
            // l=5 -> 0
            // l=4 -> 1/5
            // l=3 -> 2/5
            // l=2 -> 3/5
            // l=1 -> 4/5

            player.vx = -hx / (1 + (5 - left)/5); 
            player.vy = -hy / (1 + (5 - left)/5);

            updateHeading(1, player);
          }
        }
      }
    }

    function updateHeading(direction, player) {
      var angle = player.rotation - Math.PI; 
      var turretAngle = player.turret.rotation;
      var deltaAngle = direction * turretAngle + direction * angle;
      var hx = Math.cos(deltaAngle);
      var hy = Math.sin(deltaAngle);
      //console.log(hx + ", " + hy);

      stage.removeChild(player.heading);
      player.heading = new PIXI.Graphics();
      player.heading.lineStyle(2, 0x00FF00, 1);
      player.heading.moveTo(player.position.x - direction * (hx * 30), player.position.y - direction * (hy * 30));
      player.heading.lineTo(player.position.x - direction * (hx * 50), player.position.y - direction * (hy * 50));
      stage.addChild(player.heading);
    }

    function shootSound() {
      soundEffect(
          1046.5,           //frequency
          0,                //attack
          0.3,              //decay
          "sawtooth",       //waveform
          1,                //Volume
          -0.8,             //pan
          0,                //wait before playing
          1200,             //pitch bend amount
          false,            //reverse bend
          0,                //random pitch range
          25,               //dissonance
          [0.2, 0.2, 2000], //echo array: [delay, feedback, filter]
          undefined         //reverb array: [duration, decay, reverse?]
          );
    }

    function moveSound() {
      soundEffect(
          200,           //frequency
          0,                //attack
          0.1,              //decay
          "sawtooth",       //waveform
          1,                //Volume
          -0.8,             //pan
          0,                //wait before playing
          0,             //pitch bend amount
          false,            //reverse bend
          0,                //random pitch range
          25,               //dissonance
          [0.08, 0.2, 2000], //echo array: [delay, feedback, filter]
          undefined         //reverb array: [duration, decay, reverse?]
          );
    }

    // UTILITY
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function keyboard(keyCode) {
      var key = {};
      key.code = keyCode;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = function(event) {
        if (event.keyCode === key.code) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
        }
        event.preventDefault();
      };

      //The `upHandler`
      key.upHandler = function(event) {
        if (event.keyCode === key.code) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
        }
        event.preventDefault();
      };

      //Attach event listeners
      window.addEventListener("keydown", key.downHandler.bind(key), false);
      window.addEventListener("keyup", key.upHandler.bind(key), false);
      return key;
    }

    function deg2rad(degrees) {
      var rads = degrees * Math.PI / 180;
      return rads;
    }

    function rad2deg(radians) {
      var degs = radians * 180 / Math.PI;
      return degs;
    }
  </script>
  </body>
</html>
